@startuml Motor_Command_Sequence
!theme plain

title ESP32 Stepper Motor Controller - Motor Command Processing Sequence

participant "BLE\nClient" as Client
participant "BLE\nStack" as BLE
participant "GATT\nServer" as GATT
participant "LED\nController" as LED
participant "Motor\nQueue" as Queue
participant "Motor\nTask" as MotorTask
participant "GPIO\nDriver" as GPIO
participant "Stepper\nMotor" as Hardware

== Motor Position Command ==
Client -> BLE : Write motor position characteristic
activate BLE
BLE -> GATT : Characteristic write event
activate GATT

GATT -> GATT : Parse command data [position:2 bytes]
GATT -> GATT : Validate position limits

GATT -> LED : flash_led(LED1, 50ms)
activate LED
LED -> GPIO : gpio_set_level(LED1, 1)
LED -> LED : vTaskDelay(50ms)
LED -> GPIO : gpio_set_level(LED1, 0)
deactivate LED

GATT -> GATT : Create motor command
note right : cmd.command = MOTOR_CMD_MOVE_ABSOLUTE\ncmd.parameter = target_position

GATT -> Queue : xQueueSend(motor_command_queue, &cmd, 100ms)
activate Queue

alt Queue send successful
    Queue --> GATT : pdTRUE
    GATT -> BLE : Return success response
    BLE --> Client : Write response OK
    
    GATT -> LED : flash_led(LED1, 200ms)
    activate LED
    LED -> GPIO : gpio_set_level(LED1, 1)
    LED -> LED : vTaskDelay(200ms)
    LED -> GPIO : gpio_set_level(LED1, 0)
    deactivate LED
else Queue full
    Queue --> GATT : pdFALSE
    GATT -> GATT : ESP_LOGE("Failed to send command")
    GATT -> BLE : Return error response
    BLE --> Client : Write response ERROR
end

deactivate GATT
deactivate BLE

== Motor Task Processing ==
MotorTask -> Queue : xQueueReceive(motor_command_queue, &cmd, 10ms)
activate MotorTask
Queue --> MotorTask : motor_cmd_msg_t

MotorTask -> MotorTask : Process MOTOR_CMD_MOVE_ABSOLUTE
MotorTask -> MotorTask : motor->target_position = parameter
MotorTask -> MotorTask : Clamp to position limits
MotorTask -> MotorTask : motor->is_moving = true
MotorTask -> MotorTask : ESP_LOGI("Moving to position: %d", parameter)

deactivate Queue

== Step Generation Loop ==
loop while current_position != target_position
    MotorTask -> MotorTask : Check for fault condition
    MotorTask -> GPIO : gpio_get_level(fault_pin)
    GPIO --> MotorTask : pin_level
    
    alt No fault detected
        alt current_position < target_position
            MotorTask -> MotorTask : direction = forward
            MotorTask -> MotorTask : current_step = (current_step + 1) % 4
            MotorTask -> MotorTask : current_position++
        else current_position > target_position
            MotorTask -> MotorTask : direction = backward
            MotorTask -> MotorTask : current_step = (current_step + 3) % 4
            MotorTask -> MotorTask : current_position--
        end
        
        MotorTask -> MotorTask : set_motor_step(motor, current_step)
        
        alt Step 0: [AIN1=1, AIN2=0, BIN1=1, BIN2=0]
            MotorTask -> GPIO : gpio_set_level(AIN1, 1)
            MotorTask -> GPIO : gpio_set_level(AIN2, 0)
            MotorTask -> GPIO : gpio_set_level(BIN1, 1)
            MotorTask -> GPIO : gpio_set_level(BIN2, 0)
        else Step 1: [AIN1=0, AIN2=1, BIN1=1, BIN2=0]
            MotorTask -> GPIO : gpio_set_level(AIN1, 0)
            MotorTask -> GPIO : gpio_set_level(AIN2, 1)
            MotorTask -> GPIO : gpio_set_level(BIN1, 1)
            MotorTask -> GPIO : gpio_set_level(BIN2, 0)
        else Step 2: [AIN1=0, AIN2=1, BIN1=0, BIN2=1]
            MotorTask -> GPIO : gpio_set_level(AIN1, 0)
            MotorTask -> GPIO : gpio_set_level(AIN2, 1)
            MotorTask -> GPIO : gpio_set_level(BIN1, 0)
            MotorTask -> GPIO : gpio_set_level(BIN2, 1)
        else Step 3: [AIN1=1, AIN2=0, BIN1=0, BIN2=1]
            MotorTask -> GPIO : gpio_set_level(AIN1, 1)
            MotorTask -> GPIO : gpio_set_level(AIN2, 0)
            MotorTask -> GPIO : gpio_set_level(BIN1, 0)
            MotorTask -> GPIO : gpio_set_level(BIN2, 1)
        end
        
        GPIO -> Hardware : Apply pin states
        Hardware -> Hardware : Execute one step
        
        MotorTask -> MotorTask : vTaskDelay(speed_delay_ms)
        
    else Fault detected
        MotorTask -> MotorTask : ESP_LOGE("Motor fault detected!")
        MotorTask -> MotorTask : motor->is_moving = false
        MotorTask -> MotorTask : motor_stop_pins(motor)
        MotorTask -> GPIO : Set all motor pins LOW
        break
    end
end

== Movement Complete ==
MotorTask -> MotorTask : Target position reached
MotorTask -> MotorTask : motor->is_moving = false
MotorTask -> MotorTask : motor_stop_pins(motor)
MotorTask -> GPIO : Set all motor pins LOW
MotorTask -> MotorTask : ESP_LOGI("Reached target position: %d", current_position)

== BLE Notification Update ==
opt Client subscribed to notifications
    MotorTask -> GATT : Update position characteristic
    activate GATT
    GATT -> GATT : Prepare position data
    GATT -> BLE : ble_gatts_chr_updated(position_handle)
    activate BLE
    BLE -> Client : Position notification
    deactivate BLE
    
    GATT -> GATT : Prepare status data
    GATT -> BLE : ble_gatts_chr_updated(status_handle)
    activate BLE
    BLE -> Client : Status notification
    deactivate BLE
    deactivate GATT
end

== Alternative Command Types ==

group Motor Stop Command
    Client -> BLE : Write motor command [STOP]
    BLE -> GATT : Command write event
    GATT -> LED : flash_led(LED4, 100ms)
    GATT -> Queue : Send MOTOR_CMD_STOP
    MotorTask -> Queue : Receive stop command
    MotorTask -> MotorTask : motor->is_moving = false
    MotorTask -> MotorTask : motor_stop_pins(motor)
    MotorTask -> MotorTask : ESP_LOGI("Motor stopped")
end

group Motor Home Command
    Client -> BLE : Write motor command [HOME]
    BLE -> GATT : Command write event
    GATT -> LED : flash_led(LED3, 500ms)
    GATT -> Queue : Send MOTOR_CMD_HOME
    MotorTask -> Queue : Receive home command
    MotorTask -> MotorTask : motor->target_position = 0
    MotorTask -> MotorTask : motor->is_moving = true
    note right : Execute step generation loop\nuntil position = 0
end

group Speed Change Command
    Client -> BLE : Write motor speed [1-1000ms]
    BLE -> GATT : Speed write event
    GATT -> LED : Double flash LED1
    GATT -> Queue : Send MOTOR_CMD_SET_SPEED
    MotorTask -> Queue : Receive speed command
    MotorTask -> MotorTask : motor->speed_delay_ms = parameter
    MotorTask -> MotorTask : Validate speed limits
    MotorTask -> MotorTask : ESP_LOGI("Speed set to: %d ms", parameter)
end

deactivate MotorTask

note over Client, Hardware : Command processing complete\nSystem ready for next command

@enduml 